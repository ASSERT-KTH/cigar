{
    "patch": "private Node tryFoldShift(Node n, Node left, Node right) {\n    if (left.isNumber() && right.isNumber()) {\n        double lval = left.getDouble();\n        double rval = right.getDouble();\n\n        int shiftAmount;\n        if (rval >= 0 && rval < 32) {\n            shiftAmount = (int) rval;\n        } else {\n            changeToNumber(Node.newNumber(0));\n            String message = rval < 0 ?\n                    SHIFT_AMOUNT_SHOULD_BE_POSITIVE : SHIFT_AMOUNT_OUT_OF_BOUNDS;\n            error(\n                    message,\n                    right\n            );\n            return n;\n        }\n\n        if (lval == (long) lval) {\n            long lvalLong = (long) lval;\n            long result;\n            switch (n.getType()) {\n                case Token.LSH:\n                    result = lvalLong << shiftAmount;\n                    break;\n                case Token.RSH:\n                    result = lvalLong >> shiftAmount;\n                    break;\n                case Token.URSH:\n                    result = lvalLong >>> shiftAmount;\n                    break;\n                default:\n                    throw new AssertionError(\"Unknown shift operator: \" +\n                            Node.tokenToName(n.getType()));\n            }\n\n            if (result != (int) result) {\n                changeToNumber(Node.newNumber(0));\n                error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n                return n;\n            }\n\n            Node newNumber = Node.newNumber((int) result);\n            n.getParent().replaceChild(n, newNumber);\n            reportCodeChange();\n            return newNumber;\n        } else {\n            changeToNumber(Node.newNumber(0));\n            error(FRACTIONAL_BITWISE_OPERAND, left);\n            return n;\n        }\n    }\n    return n;\n}\n\nprivate void changeToNumber(Node node) {\n    node.setType(Token.NUMBER);\n    node.setDouble(0.0);\n    node.removeChildren();\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex d6c194a3..de7cee4c 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -649,68 +649,67 @@ public class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n   /**\n    * Try to fold shift operations\n    */\n-  private Node tryFoldShift(Node n, Node left, Node right) {\n-    if (left.getType() == Token.NUMBER &&\n-        right.getType() == Token.NUMBER) {\n-\n-      double result;\n-      double lval = left.getDouble();\n-      double rval = right.getDouble();\n-\n-      // check ranges.  We do not do anything that would clip the double to\n-      // a 32-bit range, since the user likely does not intend that.\n-      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n-        error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n-        return n;\n-      }\n-\n-      // only the lower 5 bits are used when shifting, so don't do anything\n-      // if the shift amount is outside [0,32)\n-      if (!(rval >= 0 && rval < 32)) {\n-        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n-        return n;\n-      }\n-\n-      // Convert the numbers to ints\n-      int lvalInt = (int) lval;\n-      if (lvalInt != lval) {\n-        error(FRACTIONAL_BITWISE_OPERAND, left);\n-        return n;\n-      }\n-\n-      int rvalInt = (int) rval;\n-      if (rvalInt != rval) {\n-        error(FRACTIONAL_BITWISE_OPERAND, right);\n-        return n;\n-      }\n+private Node tryFoldShift(Node n, Node left, Node right) {\n+    if (left.isNumber() && right.isNumber()) {\n+        double lval = left.getDouble();\n+        double rval = right.getDouble();\n+\n+        int shiftAmount;\n+        if (rval >= 0 && rval < 32) {\n+            shiftAmount = (int) rval;\n+        } else {\n+            changeToNumber(Node.newNumber(0));\n+            String message = rval < 0 ?\n+                    SHIFT_AMOUNT_SHOULD_BE_POSITIVE : SHIFT_AMOUNT_OUT_OF_BOUNDS;\n+            error(\n+                    message,\n+                    right\n+            );\n+            return n;\n+        }\n \n-      switch (n.getType()) {\n-        case Token.LSH:\n-          result = lvalInt << rvalInt;\n-          break;\n-        case Token.RSH:\n-          result = lvalInt >> rvalInt;\n-          break;\n-        case Token.URSH:\n-          // JavaScript handles zero shifts on signed numbers differently than\n-          // Java as an Java int can not represent the unsigned 32-bit number\n-          // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n-          break;\n-        default:\n-          throw new AssertionError(\"Unknown shift operator: \" +\n-              Node.tokenToName(n.getType()));\n-      }\n+        if (lval == (long) lval) {\n+            long lvalLong = (long) lval;\n+            long result;\n+            switch (n.getType()) {\n+                case Token.LSH:\n+                    result = lvalLong << shiftAmount;\n+                    break;\n+                case Token.RSH:\n+                    result = lvalLong >> shiftAmount;\n+                    break;\n+                case Token.URSH:\n+                    result = lvalLong >>> shiftAmount;\n+                    break;\n+                default:\n+                    throw new AssertionError(\"Unknown shift operator: \" +\n+                            Node.tokenToName(n.getType()));\n+            }\n \n-      Node newNumber = Node.newNumber(result);\n-      n.getParent().replaceChild(n, newNumber);\n-      reportCodeChange();\n+            if (result != (int) result) {\n+                changeToNumber(Node.newNumber(0));\n+                error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n+                return n;\n+            }\n \n-      return newNumber;\n+            Node newNumber = Node.newNumber((int) result);\n+            n.getParent().replaceChild(n, newNumber);\n+            reportCodeChange();\n+            return newNumber;\n+        } else {\n+            changeToNumber(Node.newNumber(0));\n+            error(FRACTIONAL_BITWISE_OPERAND, left);\n+            return n;\n+        }\n     }\n-\n     return n;\n-  }\n+}\n+\n+private void changeToNumber(Node node) {\n+    node.setType(Token.NUMBER);\n+    node.setDouble(0.0);\n+    node.removeChildren();\n+}\n \n   /**\n    * Try to fold comparison nodes, e.g ==",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}