{
    "patch": "        // iterate over step size, ensuring local normalized error is smaller than 1\n        double error = 10;\n        while (error >= 1.0) {\n\n            if (firstTime || !fsal) {\n                // first stage\n                computeDerivatives(stepStart, y, yDotK[0]);\n            }\n\n            if (firstTime) {\n                final double[] scale = new double[mainSetDimension];\n                if (vecAbsoluteTolerance == null) {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n                    }\n                } else {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n                    }\n                }\n                hNew = initializeStep(forward, getOrder(), scale,\n                                      stepStart, y, yDotK[0], yTmp, yDotK[1]);\n                firstTime = false;\n            }\n\n            stepSize = hNew;\n\n            // next stages\n            for (int k = 1; k < stages; ++k) {\n\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k-1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k-1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n\n                computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n            }\n\n            // estimate the state at the end of the step\n            for (int j = 0; j < y0.length; ++j) {\n                double sum    = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum    += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n\n            // estimate the error at the end of the step\n            error = estimateError(yDotK, y, yTmp, stepSize);\n            if (error >= 1.0) {\n                // reject the step and attempt to reduce error by stepsize control\n                final double factor =\n                        FastMath.min(maxGrowth,\n                                     FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n                hNew = filterStep(stepSize * factor, forward, false);\n            }\n\n        } // end of while loop\n\n        // local error is small enough: accept the step, trigger events and step handlers\n        interpolator.storeTime(stepStart + stepSize);\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\n        System.arraycopy(y, 0, yTmp, 0, y.length);\n\n        if (!isLastStep) {\n\n            // prepare next step\n            interpolator.storeTime(stepStart);\n\n            if (fsal) {\n                // save the last evaluation for the next step\n                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n            }\n\n            // stepsize control for next step\n            final double factor =\n                    FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n            final double  scaledH    = stepSize * factor;\n            final double  nextT      = stepStart + scaledH;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            hNew = filterStep(scaledH, forward, nextIsLast);\n\n            final double  filteredNextT      = stepStart + hNew;\n            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n            if (filteredNextIsLast) {\n                hNew = t - stepStart;\n            }\n\n        } // end of if (!isLastStep) block\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 13ced27d7..e922d3d6d 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,6 +247,111 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         stepSize = hNew;\n+        // iterate over step size, ensuring local normalized error is smaller than 1\n+        double error = 10;\n+        while (error >= 1.0) {\n+\n+            if (firstTime || !fsal) {\n+                // first stage\n+                computeDerivatives(stepStart, y, yDotK[0]);\n+            }\n+\n+            if (firstTime) {\n+                final double[] scale = new double[mainSetDimension];\n+                if (vecAbsoluteTolerance == null) {\n+                    for (int i = 0; i < scale.length; ++i) {\n+                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n+                    }\n+                } else {\n+                    for (int i = 0; i < scale.length; ++i) {\n+                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n+                    }\n+                }\n+                hNew = initializeStep(forward, getOrder(), scale,\n+                                      stepStart, y, yDotK[0], yTmp, yDotK[1]);\n+                firstTime = false;\n+            }\n+\n+            stepSize = hNew;\n+\n+            // next stages\n+            for (int k = 1; k < stages; ++k) {\n+\n+                for (int j = 0; j < y0.length; ++j) {\n+                    double sum = a[k-1][0] * yDotK[0][j];\n+                    for (int l = 1; l < k; ++l) {\n+                        sum += a[k-1][l] * yDotK[l][j];\n+                    }\n+                    yTmp[j] = y[j] + stepSize * sum;\n+                }\n+\n+                computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n+\n+            }\n+\n+            // estimate the state at the end of the step\n+            for (int j = 0; j < y0.length; ++j) {\n+                double sum    = b[0] * yDotK[0][j];\n+                for (int l = 1; l < stages; ++l) {\n+                    sum    += b[l] * yDotK[l][j];\n+                }\n+                yTmp[j] = y[j] + stepSize * sum;\n+            }\n+\n+            // estimate the error at the end of the step\n+            error = estimateError(yDotK, y, yTmp, stepSize);\n+            if (error >= 1.0) {\n+                // reject the step and attempt to reduce error by stepsize control\n+                final double factor =\n+                        FastMath.min(maxGrowth,\n+                                     FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n+                hNew = filterStep(stepSize * factor, forward, false);\n+            }\n+\n+        } // end of while loop\n+\n+        // local error is small enough: accept the step, trigger events and step handlers\n+        interpolator.storeTime(stepStart + stepSize);\n+        System.arraycopy(yTmp, 0, y, 0, y0.length);\n+        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n+        stepStart = acceptStep(interpolator, y, yDotTmp, t);\n+        System.arraycopy(y, 0, yTmp, 0, y.length);\n+\n+        if (!isLastStep) {\n+\n+            // prepare next step\n+            interpolator.storeTime(stepStart);\n+\n+            if (fsal) {\n+                // save the last evaluation for the next step\n+                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n+            }\n+\n+            // stepsize control for next step\n+            final double factor =\n+                    FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n+            final double  scaledH    = stepSize * factor;\n+            final double  nextT      = stepStart + scaledH;\n+            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n+            hNew = filterStep(scaledH, forward, nextIsLast);\n+\n+            final double  filteredNextT      = stepStart + hNew;\n+            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n+            if (filteredNextIsLast) {\n+                hNew = t - stepStart;\n+            }\n+\n+        } // end of if (!isLastStep) block\n+\n+    } while (!isLastStep);\n+\n+    // dispatch results\n+    equations.setTime(stepStart);\n+    equations.setCompleteState(y);\n+\n+    resetInternalState();\n+\n+}\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {",
    "result_reason": "error: while expected",
    "test_result": "ERROR"
}