{
    "patch": "public Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n                mockingProgress.getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n            mockingProgress.getArgumentMatcherStorage(), invocation);\n\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n    if (verificationMode != null && verificationMode instanceof MockAwareVerificationMode) {\n        MockAwareVerificationMode mockAwareVerificationMode = (MockAwareVerificationMode) verificationMode;\n        if (mockAwareVerificationMode.getMock().equals(invocation.getMock())) {\n            VerificationDataImpl data = new VerificationDataImp",
    "patch_diff": "diff --git a/src/org/mockito/internal/MockHandler.java b/src/org/mockito/internal/MockHandler.java\nindex 6f2e4bcfd..5b32d78a5 100644\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n@@ -55,55 +55,24 @@ public class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInte\n         this(oldMockHandler.getMockSettings());\n     }\n \n-    public Object handle(Invocation invocation) throws Throwable {\n-        if (invocationContainerImpl.hasAnswersForStubbing()) {\n-            // stubbing voids with stubVoid() or doAnswer() style\n-            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n-                            .getArgumentMatcherStorage(), invocation);\n-            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n-            return null;\n-        }\n-        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n-\n-        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n-                        invocation);\n-\n-        mockingProgress.validateState();\n-\n-        //if verificationMode is not null then someone is doing verify()        \n-        if (verificationMode != null) {\n-            //We need to check if verification was started on the correct mock \n-            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n-                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n-                verificationMode.verify(data);\n-                return null;\n-                // this means there is an invocation on a different mock. Re-adding verification mode \n-                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            }\n-        }\n-        \n-        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n-        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n-        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n-\n-        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n-\n-        if (stubbedInvocation != null) {\n-            stubbedInvocation.captureArgumentsFrom(invocation);\n-            return stubbedInvocation.answer(invocation);\n-        } else {\n-            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n-\n-            // redo setting invocation for potential stubbing in case of partial\n-            // mocks / spies.\n-            // Without it, the real method inside 'when' might have delegated\n-            // to other self method and overwrite the intended stubbed method\n-            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n-            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n-            return ret;\n-        }\n-    }\n+\n+public Object handle(Invocation invocation) throws Throwable {\n+    if (invocationContainerImpl.hasAnswersForStubbing()) {\n+        // stubbing voids with stubVoid() or doAnswer() style\n+        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                mockingProgress.getArgumentMatcherStorage(), invocation);\n+        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n+        return null;\n+    }\n+\n+    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+            mockingProgress.getArgumentMatcherStorage(), invocation);\n+\n+    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n+    if (verificationMode != null && verificationMode instanceof MockAwareVerificationMode) {\n+        MockAwareVerificationMode mockAwareVerificationMode = (MockAwareVerificationMode) verificationMode;\n+        if (mockAwareVerificationMode.getMock().equals(invocation.getMock())) {\n+            VerificationDataImpl data = new VerificationDataImp\n \n     public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n         return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n@@ -121,4 +90,4 @@ public class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInte\n     public InvocationContainer getInvocationContainer() {\n         return invocationContainerImpl;\n     }\n-}\n\\ No newline at end of file\n+}",
    "result_reason": "error: '(' or '[' expected",
    "test_result": "ERROR"
}