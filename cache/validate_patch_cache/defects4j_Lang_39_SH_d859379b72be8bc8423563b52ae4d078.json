{
    "patch": "    private static String replaceEach(String text, String[] searchList, String[] replacementList,\n                                      boolean repeat, int timeToLive)\n    {\n\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n\n        if (text == null || text.length() == 0 || searchList == null ||\n                searchList.length == 0 || replacementList == null || replacementList.length == 0)\n        {\n            return text;\n        }\n\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        // make sure lengths are ok, these need to be equal\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                    + searchLength\n                    + \" vs \"\n                    + replacementLength);\n        }\n\n        // keep track of which still have matches\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        // index on index that the match was found\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                    searchList[i].length() == 0 || replacementList[i] == null)\n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n\n        // no search strings found, we are done\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n        int increase = 0;\n\n        // count the replacement text elements that are larger than their corresponding text being replaced\n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; // assume 3 matches\n            }\n        }\n        // have upper-bound at 20% increase, then let Java take over\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                        searchList[i].length() == 0 || replacementList[i] == null)",
    "patch_diff": "diff --git a/src/java/org/apache/commons/lang3/StringUtils.java b/src/java/org/apache/commons/lang3/StringUtils.java\nindex 14563aa6..a533602b 100644\n--- a/src/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/java/org/apache/commons/lang3/StringUtils.java\n@@ -3673,6 +3673,107 @@ public class StringUtils {\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n         for (int i = 0; i < searchList.length; i++) {\n+    private static String replaceEach(String text, String[] searchList, String[] replacementList,\n+                                      boolean repeat, int timeToLive)\n+    {\n+\n+        // mchyzer Performance note: This creates very few new objects (one major goal)\n+        // let me know if there are performance requests, we can create a harness to measure\n+\n+        if (text == null || text.length() == 0 || searchList == null ||\n+                searchList.length == 0 || replacementList == null || replacementList.length == 0)\n+        {\n+            return text;\n+        }\n+\n+        // if recursing, this shouldnt be less than 0\n+        if (timeToLive < 0) {\n+            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n+        }\n+\n+        int searchLength = searchList.length;\n+        int replacementLength = replacementList.length;\n+\n+        // make sure lengths are ok, these need to be equal\n+        if (searchLength != replacementLength) {\n+            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n+                    + searchLength\n+                    + \" vs \"\n+                    + replacementLength);\n+        }\n+\n+        // keep track of which still have matches\n+        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n+\n+        // index on index that the match was found\n+        int textIndex = -1;\n+        int replaceIndex = -1;\n+        int tempIndex = -1;\n+\n+        // index of replace array that will replace the search string found\n+        // NOTE: logic duplicated below START\n+        for (int i = 0; i < searchLength; i++) {\n+            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n+                    searchList[i].length() == 0 || replacementList[i] == null)\n+            {\n+                continue;\n+            }\n+            tempIndex = text.indexOf(searchList[i]);\n+\n+            // see if we need to keep searching for this\n+            if (tempIndex == -1) {\n+                noMoreMatchesForReplIndex[i] = true;\n+            } else {\n+                if (textIndex == -1 || tempIndex < textIndex) {\n+                    textIndex = tempIndex;\n+                    replaceIndex = i;\n+                }\n+            }\n+        }\n+        // NOTE: logic mostly below END\n+\n+        // no search strings found, we are done\n+        if (textIndex == -1) {\n+            return text;\n+        }\n+\n+        int start = 0;\n+\n+        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n+        int increase = 0;\n+\n+        // count the replacement text elements that are larger than their corresponding text being replaced\n+        for (int i = 0; i < searchList.length; i++) {\n+            if (searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n+                continue;\n+            }\n+            int greater = replacementList[i].length() - searchList[i].length();\n+            if (greater > 0) {\n+                increase += 3 * greater; // assume 3 matches\n+            }\n+        }\n+        // have upper-bound at 20% increase, then let Java take over\n+        increase = Math.min(increase, text.length() / 5);\n+\n+        StringBuilder buf = new StringBuilder(text.length() + increase);\n+\n+        while (textIndex != -1) {\n+\n+            for (int i = start; i < textIndex; i++) {\n+                buf.append(text.charAt(i));\n+            }\n+            buf.append(replacementList[replaceIndex]);\n+\n+            start = textIndex + searchList[replaceIndex].length();\n+\n+            textIndex = -1;\n+            replaceIndex = -1;\n+            tempIndex = -1;\n+            // find the next earliest match\n+            // NOTE: logic mostly duplicated above START\n+            for (int i = 0; i < searchLength; i++) {\n+                if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n+                        searchList[i].length() == 0 || replacementList[i] == null)\n             int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}