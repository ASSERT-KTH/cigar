{
    "patch": "static String strEscape(String s, char quote,\n    String doublequoteEscape,\n    String singlequoteEscape,\n    String backslashEscape,\n    CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case 0: sb.append(\"\\\\[\\\\]0\"); break; // Null character\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                      // Break --> into --\\> or ]]> into ]]\\>\n        if (i >= 2 &&\n          ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n          (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        // Break </script into <\\/script\n        final String END_SCRIPT = \"/script\";\n        // Break <!-- into <\\!--\n        final String START_COMMENT = \"!--\";\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n            START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        // If we're given an outputCharsetEncoder, then check if the\n        // character can be represented in this character set.\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            // Unicode-escape the character.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          // No charsetEncoder provided - pass straight latin characters\n          // through, and escape the rest. Doing the explicit character\n          // check is measurably faster than using the CharsetEncoder.\n          if (c > 0x1f && c <= 0x7f) {\n            sb.append(c);\n          } else {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\nprivate static void appendHexJavaScriptRepresentation(StringBuilder sb, char c) {\n  if (c == 0) {\n    sb.append(\"\\\\[\\\\]0\");\n  } else {\n    sb.append(\"\\\\u\");\n    sb.append(Character.forDigit((c >> 12) & 15, 16));\n    sb.append(Character.forDigit((c >> 8) & 15, 16));\n    sb.append(Character.forDigit((c >> 4) & 15, 16));\n    sb.append(Character.forDigit((c) & 15, 16));\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 8cd3ab9d..d2af3670 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -953,76 +953,87 @@ class CodeGenerator {\n   }\n \n   /** Helper to escape javascript string as well as regular expression */\n-  static String strEscape(String s, char quote,\n-                          String doublequoteEscape,\n-                          String singlequoteEscape,\n-                          String backslashEscape,\n-                          CharsetEncoder outputCharsetEncoder) {\n-    StringBuilder sb = new StringBuilder(s.length() + 2);\n-    sb.append(quote);\n-    for (int i = 0; i < s.length(); i++) {\n-      char c = s.charAt(i);\n-      switch (c) {\n-        case '\\n': sb.append(\"\\\\n\"); break;\n-        case '\\r': sb.append(\"\\\\r\"); break;\n-        case '\\t': sb.append(\"\\\\t\"); break;\n-        case '\\\\': sb.append(backslashEscape); break;\n-        case '\\\"': sb.append(doublequoteEscape); break;\n-        case '\\'': sb.append(singlequoteEscape); break;\n-        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n-          if (i >= 2 &&\n-              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n-               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n-            sb.append(\"\\\\>\");\n-          } else {\n+static String strEscape(String s, char quote,\n+    String doublequoteEscape,\n+    String singlequoteEscape,\n+    String backslashEscape,\n+    CharsetEncoder outputCharsetEncoder) {\n+  StringBuilder sb = new StringBuilder(s.length() + 2);\n+  sb.append(quote);\n+  for (int i = 0; i < s.length(); i++) {\n+    char c = s.charAt(i);\n+    switch (c) {\n+      case 0: sb.append(\"\\\\[\\\\]0\"); break; // Null character\n+      case '\\n': sb.append(\"\\\\n\"); break;\n+      case '\\r': sb.append(\"\\\\r\"); break;\n+      case '\\t': sb.append(\"\\\\t\"); break;\n+      case '\\\\': sb.append(backslashEscape); break;\n+      case '\\\"': sb.append(doublequoteEscape); break;\n+      case '\\'': sb.append(singlequoteEscape); break;\n+      case '>':                      // Break --> into --\\> or ]]> into ]]\\>\n+        if (i >= 2 &&\n+          ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n+          (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n+          sb.append(\"\\\\>\");\n+        } else {\n+          sb.append(c);\n+        }\n+        break;\n+      case '<':\n+        // Break </script into <\\/script\n+        final String END_SCRIPT = \"/script\";\n+        // Break <!-- into <\\!--\n+        final String START_COMMENT = \"!--\";\n+        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n+            END_SCRIPT.length())) {\n+          sb.append(\"<\\\\\");\n+        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n+            START_COMMENT.length())) {\n+          sb.append(\"<\\\\\");\n+        } else {\n+          sb.append(c);\n+        }\n+        break;\n+      default:\n+        // If we're given an outputCharsetEncoder, then check if the\n+        // character can be represented in this character set.\n+        if (outputCharsetEncoder != null) {\n+          if (outputCharsetEncoder.canEncode(c)) {\n             sb.append(c);\n-          }\n-          break;\n-        case '<':\n-          // Break </script into <\\/script\n-          final String END_SCRIPT = \"/script\";\n-\n-          // Break <!-- into <\\!--\n-          final String START_COMMENT = \"!--\";\n-\n-          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n-                              END_SCRIPT.length())) {\n-            sb.append(\"<\\\\\");\n-          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n-                                     START_COMMENT.length())) {\n-            sb.append(\"<\\\\\");\n           } else {\n-            sb.append(c);\n+            // Unicode-escape the character.\n+            appendHexJavaScriptRepresentation(sb, c);\n           }\n-          break;\n-        default:\n-          // If we're given an outputCharsetEncoder, then check if the\n-          //  character can be represented in this character set.\n-          if (outputCharsetEncoder != null) {\n-            if (outputCharsetEncoder.canEncode(c)) {\n-              sb.append(c);\n-            } else {\n-              // Unicode-escape the character.\n-              appendHexJavaScriptRepresentation(sb, c);\n-            }\n+        } else {\n+          // No charsetEncoder provided - pass straight latin characters\n+          // through, and escape the rest. Doing the explicit character\n+          // check is measurably faster than using the CharsetEncoder.\n+          if (c > 0x1f && c <= 0x7f) {\n+            sb.append(c);\n           } else {\n-            // No charsetEncoder provided - pass straight latin characters\n-            // through, and escape the rest.  Doing the explicit character\n-            // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n-              sb.append(c);\n-            } else {\n-              // Other characters can be misinterpreted by some js parsers,\n-              // or perhaps mangled by proxies along the way,\n-              // so we play it safe and unicode escape them.\n-              appendHexJavaScriptRepresentation(sb, c);\n-            }\n+            // Other characters can be misinterpreted by some js parsers,\n+            // or perhaps mangled by proxies along the way,\n+            // so we play it safe and unicode escape them.\n+            appendHexJavaScriptRepresentation(sb, c);\n           }\n-      }\n+        }\n     }\n-    sb.append(quote);\n-    return sb.toString();\n   }\n+  sb.append(quote);\n+  return sb.toString();\n+}\n+\n+private static void appendHexJavaScriptRepresentation(StringBuilder sb, char c) {\n+  if (c == 0) {\n+    sb.append(\"\\\\[\\\\]0\");\n+  } else {\n+    sb.append(\"\\\\u\");\n+    sb.append(Character.forDigit((c >> 12) & 15, 16));\n+    sb.append(Character.forDigit((c >> 8) & 15, 16));\n+    sb.append(Character.forDigit((c >> 4) & 15, 16));\n+    sb.append(Character.forDigit((c) & 15, 16));\n+  }\n+}\n \n   static String identifierEscape(String s) {\n     // First check if escaping is needed at all -- in most cases it isn't.",
    "result_reason": "error: method appendHexJavaScriptRepresentation(StringBuilder,char) is already defined in class CodeGenerator",
    "test_result": "ERROR"
}