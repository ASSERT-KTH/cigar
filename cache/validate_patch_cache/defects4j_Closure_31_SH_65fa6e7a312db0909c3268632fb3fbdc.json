{
    "patch": "        if (externsRoot != null) {\n            externsRoot.detachChildren();\n        }\n        if (jsRoot != null) {\n            jsRoot.detachChildren();\n        }\n\n        // Parse main js sources.\n        jsRoot = IR.block();\n        jsRoot.setIsSyntheticBlock(true);\n\n        externsRoot = IR.block();\n        externsRoot.setIsSyntheticBlock(true);\n\n        externAndJsRoot = IR.block(externsRoot, jsRoot);\n        externAndJsRoot.setIsSyntheticBlock(true);\n\n        if (options.tracer.isOn()) {\n            tracker = new PerformanceTracker(jsRoot, options.tracer);\n            addChangeHandler(tracker.getCodeChangeHandler());\n        }\n\n        Tracer tracer = newTracer(\"parseInputs\");\n\n        try {\n            // Parse externs sources.\n            for (CompilerInput input : externs) {\n                Node n = input.getAstRoot(this);\n                if (hasErrors()) {\n                    return null;\n                }\n                externsRoot.addChildToBack(n);\n            }\n\n            // Modules inferred in ProcessCommonJS pass.\n            if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n                processAMDAndCommonJSModules();\n            }\n\n            // Check if inputs need to be rebuilt from modules.\n            boolean staleInputs = false;\n\n            // Check if the sources need to be re-ordered.\n            if (options.dependencyOptions != null && options.dependencyOptions.needsManagement() && options.closurePass) {\n                for (CompilerInput input : inputs) {\n                    // Forward-declare all the provided types, so that they\n                    // are not flagged even if they are dropped from the process.\n                    for (String provide : input.getProvides()) {\n                        getTypeRegistry().forwardDeclareType(provide);\n                    }\n                }\n\n                try {\n                    inputs =\n                            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n                                    .manageDependencies(options.dependencyOptions, inputs);\n                    staleInputs = true;\n                } catch (CircularDependencyException e) {\n                    report(JSError.make(\n                            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n                    // If in IDE mode, we ignore the error and keep going.\n                    if (hasErrors()) {\n                        return null;\n                    }\n                } catch (MissingProvideException e) {\n                    report(JSError.make(\n                            MISSING_ENTRY_ERROR, e.getMessage()));\n\n                    // If in IDE mode, we ignore the error and keep going.\n                    if (hasErrors()) {\n                        return null;\n                    }\n                }\n            }\n\n            for (CompilerInput input : inputs) {\n                Node n = input.getAstRoot(this);\n\n                // Inputs can have a null AST during initial parse.\n                if (n == null) {\n                    continue;\n                }\n\n                if (n.getJSDocInfo() != null) {\n                    JSDocInfo info = n.getJSDocInfo();\n                    if (info.isExterns()) {\n                        // If the input file is explicitly marked as an externs file, then\n                        // assume the programmer made a mistake and throw it into\n                        // the externs pile anyways.\n                        externsRoot.addChildToBack(n);\n                        input.setIsExtern(true);\n\n                        input.getModule().remove(input);\n\n                        externs.add(input);\n                        staleInputs = true;\n                    } else if (info.isNoCompile()) {\n                        input.getModule().remove(input);\n                        staleInputs = true;\n                    }\n                }\n            }\n\n            if (staleInputs) {\n                fillEmptyModules(modules);\n                rebuildInputsFromModules();\n            }\n\n            // Build the AST.\n            for (CompilerInput input : inputs) {\n                Node n = input.getAstRoot(this);\n                if (n == null) {\n                    continue;\n                }\n\n                if (devMode) {\n                    runSanityCheck();\n                    if (hasErrors()) {\n                        return null;\n                    }\n                }\n\n                if (options.sourceMapOutputPath != null ||\n                        options.nameReferenceReportPath != null) {\n\n                    // Annotate the nodes in the tree with information from the\n                    // input file. This information is used to construct the SourceMap.\n                    SourceInformationAnnotator sia =\n                            new SourceInformationAnnotator(\n                                    input.getName(), options.devMode != DevMode.OFF);\n                    NodeTraversal.traverse(this, n, sia);\n                }\n\n                jsRoot.addChildToBack(n);\n            }\n\n            if (hasErrors()) {\n                return null;\n            }\n            return externAndJsRoot;\n        } finally {\n            stopTracer(tracer, \"parseInputs\");\n        }\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b76bbb5c..ab193a1c 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1282,7 +1282,151 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+        if (externsRoot != null) {\n+            externsRoot.detachChildren();\n+        }\n+        if (jsRoot != null) {\n+            jsRoot.detachChildren();\n+        }\n+\n+        // Parse main js sources.\n+        jsRoot = IR.block();\n+        jsRoot.setIsSyntheticBlock(true);\n+\n+        externsRoot = IR.block();\n+        externsRoot.setIsSyntheticBlock(true);\n+\n+        externAndJsRoot = IR.block(externsRoot, jsRoot);\n+        externAndJsRoot.setIsSyntheticBlock(true);\n+\n+        if (options.tracer.isOn()) {\n+            tracker = new PerformanceTracker(jsRoot, options.tracer);\n+            addChangeHandler(tracker.getCodeChangeHandler());\n+        }\n+\n+        Tracer tracer = newTracer(\"parseInputs\");\n+\n+        try {\n+            // Parse externs sources.\n+            for (CompilerInput input : externs) {\n+                Node n = input.getAstRoot(this);\n+                if (hasErrors()) {\n+                    return null;\n+                }\n+                externsRoot.addChildToBack(n);\n+            }\n+\n+            // Modules inferred in ProcessCommonJS pass.\n+            if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n+                processAMDAndCommonJSModules();\n+            }\n+\n+            // Check if inputs need to be rebuilt from modules.\n+            boolean staleInputs = false;\n+\n+            // Check if the sources need to be re-ordered.\n+            if (options.dependencyOptions != null && options.dependencyOptions.needsManagement() && options.closurePass) {\n+                for (CompilerInput input : inputs) {\n+                    // Forward-declare all the provided types, so that they\n+                    // are not flagged even if they are dropped from the process.\n+                    for (String provide : input.getProvides()) {\n+                        getTypeRegistry().forwardDeclareType(provide);\n+                    }\n+                }\n+\n+                try {\n+                    inputs =\n+                            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n+                                    .manageDependencies(options.dependencyOptions, inputs);\n+                    staleInputs = true;\n+                } catch (CircularDependencyException e) {\n+                    report(JSError.make(\n+                            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n+\n+                    // If in IDE mode, we ignore the error and keep going.\n+                    if (hasErrors()) {\n+                        return null;\n+                    }\n+                } catch (MissingProvideException e) {\n+                    report(JSError.make(\n+                            MISSING_ENTRY_ERROR, e.getMessage()));\n+\n+                    // If in IDE mode, we ignore the error and keep going.\n+                    if (hasErrors()) {\n+                        return null;\n+                    }\n+                }\n+            }\n+\n+            for (CompilerInput input : inputs) {\n+                Node n = input.getAstRoot(this);\n+\n+                // Inputs can have a null AST during initial parse.\n+                if (n == null) {\n+                    continue;\n+                }\n+\n+                if (n.getJSDocInfo() != null) {\n+                    JSDocInfo info = n.getJSDocInfo();\n+                    if (info.isExterns()) {\n+                        // If the input file is explicitly marked as an externs file, then\n+                        // assume the programmer made a mistake and throw it into\n+                        // the externs pile anyways.\n+                        externsRoot.addChildToBack(n);\n+                        input.setIsExtern(true);\n+\n+                        input.getModule().remove(input);\n+\n+                        externs.add(input);\n+                        staleInputs = true;\n+                    } else if (info.isNoCompile()) {\n+                        input.getModule().remove(input);\n+                        staleInputs = true;\n+                    }\n+                }\n+            }\n+\n+            if (staleInputs) {\n+                fillEmptyModules(modules);\n+                rebuildInputsFromModules();\n+            }\n+\n+            // Build the AST.\n+            for (CompilerInput input : inputs) {\n+                Node n = input.getAstRoot(this);\n+                if (n == null) {\n+                    continue;\n+                }\n+\n+                if (devMode) {\n+                    runSanityCheck();\n+                    if (hasErrors()) {\n+                        return null;\n+                    }\n+                }\n+\n+                if (options.sourceMapOutputPath != null ||\n+                        options.nameReferenceReportPath != null) {\n+\n+                    // Annotate the nodes in the tree with information from the\n+                    // input file. This information is used to construct the SourceMap.\n+                    SourceInformationAnnotator sia =\n+                            new SourceInformationAnnotator(\n+                                    input.getName(), options.devMode != DevMode.OFF);\n+                    NodeTraversal.traverse(this, n, sia);\n+                }\n+\n+                jsRoot.addChildToBack(n);\n+            }\n+\n+            if (hasErrors()) {\n+                return null;\n+            }\n+            return externAndJsRoot;\n+        } finally {\n+            stopTracer(tracer, \"parseInputs\");\n+        }\n+    }\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}