{
    "patch": "private void prelim(double[] lowerBound, double[] upperBound) {\n    printMethod();\n\n    final int n = currentBest.getDimension();\n    final int npt = numberOfInterpolationPoints;\n    final int ndim = bMatrix.getRowDimension();\n\n    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n    final double recip = 1d / rhosq;\n    final int np = n + 1;\n\n    // Set XBASE to the initial vector of variables, and set the initial\n    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n\n    for (int j = 0; j < n; j++) {\n        originShift.setEntry(j, currentBest.getEntry(j));\n        for (int k = 0; k < npt; k++) {\n            interpolationPoints.setEntry(k, j, 0);\n        }\n        for (int i = 0; i < ndim; i++) {\n            bMatrix.setEntry(i, j, 0);\n        }\n    }\n    for (int i = 0, max = n * np / 2; i < max; i++) {\n        modelSecondDerivativesValues.setEntry(i, 0);\n    }\n    for (int k = 0; k < npt; k++) {\n        modelSecondDerivativesParameters.setEntry(k, 0);\n        for (int j = 0, max = npt - np; j < max; j++) {\n            zMatrix.setEntry(k, j, 0);\n        }\n    }\n\n    // Begin the initialization procedure. NF becomes one more than the number\n    // of function values so far. The coordinates of the displacement of the\n    // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n\n    int ipt = 0;\n    int jpt = 0;\n    double fbeg = Double.NaN;\n    while (getEvaluations() < npt) {\n        final int nfm = getEvaluations() + 1;\n        final int nfx = nfm - n;\n        final int nfmm = nfm - 1;\n        final int nfxm = nfx - 1;\n        double stepa = 0;\n        double stepb = 0;\n        if (nfm <= 2 * n) {\n            if (nfm >= 1 && nfm <= n) {\n                stepa = initialTrustRegionRadius;\n                if (upperDifference.getEntry(nfmm) == 0) {\n                    stepa = -stepa;\n                    continue;\n                }\n                interpolationPoints.setEntry(nfm, nfmm, stepa);\n            } else if (nfm > n) {\n                stepa = interpolationPoints.getEntry(nfx, nfxm);\n                stepb = -initialTrustRegionRadius;\n                if (lowerDifference.getEntry(nfxm) == 0) {\n                    stepb = Math.min(2 * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                    continue;\n                }\n                if (upperDifference.getEntry(nfxm) == 0) {\n                    stepb = Math.max(-2 * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                    continue;\n                }\n                interpolationPoints.setEntry(nfm, nfxm, stepb);\n            }\n        } else {\n            final int tmp1 = (nfm - np) / n;\n            jpt = nfm - tmp1 * n - n;\n            ipt = jpt + tmp1;\n            if (ipt > n) {\n                final int tmp2 = jpt;\n                jpt = ipt - n;\n                ipt = tmp2;\n                continue;\n            }\n            final int iptMinus1 = ipt - 1;\n            final int jptMinus1 = jpt - 1;\n            interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n            interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n        }\n\n        // Calculate the next value of F. The least function value so far and\n        // its index are required.\n        for (int j = 0; j < n; j++) {\n            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n                    upperBound[j]));\n            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                currentBest.setEntry(j, lowerBound[j]);\n            }\n            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                currentBest.setEntry(j, upperBound[j]);\n            }\n        }\n\n        final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n        final double f = isMinimize ? objectiveValue : -objectiveValue;\n        final int numEval = getEvaluations();\n        fAtInterpolationPoints.setEntry(nfm - 1, f);\n\n        if (numEval == 1) {\n            fbeg = f;\n            trustRegionCenterInterpolationPointIndex = 0;\n        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n            trustRegionCenterInterpolationPointIndex = nfm - 1;\n        }\n\n        // Set the nonzero initial elements of BMAT and the quadratic model in the\n        // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n        // of the NF-th and (NF-N)-th interpolation points may be switched, in\n        // order that the function value at the first of them contributes to the\n        // off-diagonal second derivative terms of the initial quadratic model.\n        if (numEval <= 2 * n + 1) {\n            if (numEval >= 2 && numEval <= n + 1) {\n                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n                if (npt < numEval + n) {\n                    final double oneOverStepA = 1 / stepa;\n                    bMatrix.setEntry(0, nfmm, -oneOverStepA);\n                    bMatrix.setEntry(nfm - 1, nfmm, oneOverStepA);\n                    bMatrix.setEntry(npt + nfmm - 1, nfmm, -0.5 * rhosq);\n                    continue;\n                }\n            } else if (numEval >= n + 2) {\n                final int ih = nfx * (nfx - 1) / 2 + nfmm;\n                final double tmp = (f - fbeg) / stepb;\n                final double diff = stepb - stepa;\n                modelSecondDerivativesValues.setEntry(ih, 2 * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                if (stepa * stepb < 0) {\n                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                        fAtInterpolationPoints.setEntry(nfm - 1, fAtInterpolationPoints.getEntry(nfm - n - 1));\n                        fAtInterpolationPoints.setEntry(nfm - n - 1, f);\n                        if (trustRegionCenterInterpolationPointIndex == nfm - 1) {\n                            trustRegionCenterInterpolationPointIndex = nfm - n - 1;\n                        }\n                        interpolationPoints.setEntry(nfm - n - 1, nfxm, stepb);\n                        interpolationPoints.setEntry(nfm - 1, nfxm, stepa);\n                    }\n                }\n                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n                bMatrix.setEntry(nfm - 1, nfxm, -0.5 / interpolationPoints.getEntry(nfm - n - 1, nfxm));\n                bMatrix.setEntry(nfm - n - 1, nfxm,\n                        -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\nindex 592a2e894..0864757bf 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n@@ -1579,180 +1579,151 @@ public class BOBYQAOptimizer\n      * @param lowerBound Lower bounds.\n      * @param upperBound Upper bounds.\n      */\n-    private void prelim(double[] lowerBound,\n-                        double[] upperBound) {\n-        printMethod(); // XXX\n+private void prelim(double[] lowerBound, double[] upperBound) {\n+    printMethod();\n \n-        final int n = currentBest.getDimension();\n-        final int npt = numberOfInterpolationPoints;\n-        final int ndim = bMatrix.getRowDimension();\n+    final int n = currentBest.getDimension();\n+    final int npt = numberOfInterpolationPoints;\n+    final int ndim = bMatrix.getRowDimension();\n \n-        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n-        final double recip = 1d / rhosq;\n-        final int np = n + 1;\n+    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n+    final double recip = 1d / rhosq;\n+    final int np = n + 1;\n \n-        // Set XBASE to the initial vector of variables, and set the initial\n-        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n+    // Set XBASE to the initial vector of variables, and set the initial\n+    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n \n-        for (int j = 0; j < n; j++) {\n-            originShift.setEntry(j, currentBest.getEntry(j));\n-            for (int k = 0; k < npt; k++) {\n-                interpolationPoints.setEntry(k, j, ZERO);\n-            }\n-            for (int i = 0; i < ndim; i++) {\n-                bMatrix.setEntry(i, j, ZERO);\n-            }\n+    for (int j = 0; j < n; j++) {\n+        originShift.setEntry(j, currentBest.getEntry(j));\n+        for (int k = 0; k < npt; k++) {\n+            interpolationPoints.setEntry(k, j, 0);\n         }\n-        for (int i = 0, max = n * np / 2; i < max; i++) {\n-            modelSecondDerivativesValues.setEntry(i, ZERO);\n+        for (int i = 0; i < ndim; i++) {\n+            bMatrix.setEntry(i, j, 0);\n         }\n-        for (int k = 0; k < npt; k++) {\n-            modelSecondDerivativesParameters.setEntry(k, ZERO);\n-            for (int j = 0, max = npt - np; j < max; j++) {\n-                zMatrix.setEntry(k, j, ZERO);\n-            }\n+    }\n+    for (int i = 0, max = n * np / 2; i < max; i++) {\n+        modelSecondDerivativesValues.setEntry(i, 0);\n+    }\n+    for (int k = 0; k < npt; k++) {\n+        modelSecondDerivativesParameters.setEntry(k, 0);\n+        for (int j = 0, max = npt - np; j < max; j++) {\n+            zMatrix.setEntry(k, j, 0);\n         }\n+    }\n \n-        // Begin the initialization procedure. NF becomes one more than the number\n-        // of function values so far. The coordinates of the displacement of the\n-        // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n-\n-        int ipt = 0;\n-        int jpt = 0;\n-        double fbeg = Double.NaN;\n-        do {\n-            final int nfm = getEvaluations();\n-            final int nfx = nfm - n;\n-            final int nfmm = nfm - 1;\n-            final int nfxm = nfx - 1;\n-            double stepa = 0;\n-            double stepb = 0;\n-            if (nfm <= 2 * n) {\n-                if (nfm >= 1 &&\n-                    nfm <= n) {\n-                    stepa = initialTrustRegionRadius;\n-                    if (upperDifference.getEntry(nfmm) == ZERO) {\n-                        stepa = -stepa;\n-                        throw new PathIsExploredException(); // XXX\n-                    }\n-                    interpolationPoints.setEntry(nfm, nfmm, stepa);\n-                } else if (nfm > n) {\n-                    stepa = interpolationPoints.getEntry(nfx, nfxm);\n-                    stepb = -initialTrustRegionRadius;\n-                    if (lowerDifference.getEntry(nfxm) == ZERO) {\n-                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n-                        throw new PathIsExploredException(); // XXX\n-                    }\n-                    if (upperDifference.getEntry(nfxm) == ZERO) {\n-                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n-                        throw new PathIsExploredException(); // XXX\n-                    }\n-                    interpolationPoints.setEntry(nfm, nfxm, stepb);\n-                }\n-            } else {\n-                final int tmp1 = (nfm - np) / n;\n-                jpt = nfm - tmp1 * n - n;\n-                ipt = jpt + tmp1;\n-                if (ipt > n) {\n-                    final int tmp2 = jpt;\n-                    jpt = ipt - n;\n-                    ipt = tmp2;\n-                    throw new PathIsExploredException(); // XXX\n-                }\n-                final int iptMinus1 = ipt;\n-                final int jptMinus1 = jpt;\n-                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n-                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n+    // Begin the initialization procedure. NF becomes one more than the number\n+    // of function values so far. The coordinates of the displacement of the\n+    // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n+\n+    int ipt = 0;\n+    int jpt = 0;\n+    double fbeg = Double.NaN;\n+    while (getEvaluations() < npt) {\n+        final int nfm = getEvaluations() + 1;\n+        final int nfx = nfm - n;\n+        final int nfmm = nfm - 1;\n+        final int nfxm = nfx - 1;\n+        double stepa = 0;\n+        double stepb = 0;\n+        if (nfm <= 2 * n) {\n+            if (nfm >= 1 && nfm <= n) {\n+                stepa = initialTrustRegionRadius;\n+                if (upperDifference.getEntry(nfmm) == 0) {\n+                    stepa = -stepa;\n+                    continue;\n+                }\n+                interpolationPoints.setEntry(nfm, nfmm, stepa);\n+            } else if (nfm > n) {\n+                stepa = interpolationPoints.getEntry(nfx, nfxm);\n+                stepb = -initialTrustRegionRadius;\n+                if (lowerDifference.getEntry(nfxm) == 0) {\n+                    stepb = Math.min(2 * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n+                    continue;\n+                }\n+                if (upperDifference.getEntry(nfxm) == 0) {\n+                    stepb = Math.max(-2 * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n+                    continue;\n+                }\n+                interpolationPoints.setEntry(nfm, nfxm, stepb);\n+            }\n+        } else {\n+            final int tmp1 = (nfm - np) / n;\n+            jpt = nfm - tmp1 * n - n;\n+            ipt = jpt + tmp1;\n+            if (ipt > n) {\n+                final int tmp2 = jpt;\n+                jpt = ipt - n;\n+                ipt = tmp2;\n+                continue;\n             }\n+            final int iptMinus1 = ipt - 1;\n+            final int jptMinus1 = jpt - 1;\n+            interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n+            interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n+        }\n \n-            // Calculate the next value of F. The least function value so far and\n-            // its index are required.\n-\n-            for (int j = 0; j < n; j++) {\n-                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n-                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n-                                                 upperBound[j]));\n-                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n-                    currentBest.setEntry(j, lowerBound[j]);\n-                }\n-                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n-                    currentBest.setEntry(j, upperBound[j]);\n-                }\n+        // Calculate the next value of F. The least function value so far and\n+        // its index are required.\n+        for (int j = 0; j < n; j++) {\n+            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n+                    upperBound[j]));\n+            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n+                currentBest.setEntry(j, lowerBound[j]);\n             }\n-\n-            final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n-            final double f = isMinimize ? objectiveValue : -objectiveValue;\n-            final int numEval = getEvaluations(); // nfm + 1\n-            fAtInterpolationPoints.setEntry(nfm, f);\n-\n-            if (numEval == 1) {\n-                fbeg = f;\n-                trustRegionCenterInterpolationPointIndex = 0;\n-            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n-                trustRegionCenterInterpolationPointIndex = nfm;\n+            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n+                currentBest.setEntry(j, upperBound[j]);\n             }\n+        }\n \n-            // Set the nonzero initial elements of BMAT and the quadratic model in the\n-            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n-            // of the NF-th and (NF-N)-th interpolation points may be switched, in\n-            // order that the function value at the first of them contributes to the\n-            // off-diagonal second derivative terms of the initial quadratic model.\n+        final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n+        final double f = isMinimize ? objectiveValue : -objectiveValue;\n+        final int numEval = getEvaluations();\n+        fAtInterpolationPoints.setEntry(nfm - 1, f);\n \n-            if (numEval <= 2 * n + 1) {\n-                if (numEval >= 2 &&\n-                    numEval <= n + 1) {\n-                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n-                    if (npt < numEval + n) {\n-                        final double oneOverStepA = ONE / stepa;\n-                        bMatrix.setEntry(0, nfmm, -oneOverStepA);\n-                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n-                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n-                        throw new PathIsExploredException(); // XXX\n-                    }\n-                } else if (numEval >= n + 2) {\n-                    final int ih = nfx * (nfx + 1) / 2 - 1;\n-                    final double tmp = (f - fbeg) / stepb;\n-                    final double diff = stepb - stepa;\n-                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n-                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n-                    if (stepa * stepb < ZERO) {\n-                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n-                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n-                            fAtInterpolationPoints.setEntry(nfm - n, f);\n-                            if (trustRegionCenterInterpolationPointIndex == nfm) {\n-                                trustRegionCenterInterpolationPointIndex = nfm - n;\n-                            }\n-                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n-                            interpolationPoints.setEntry(nfm, nfxm, stepa);\n+        if (numEval == 1) {\n+            fbeg = f;\n+            trustRegionCenterInterpolationPointIndex = 0;\n+        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n+            trustRegionCenterInterpolationPointIndex = nfm - 1;\n+        }\n+\n+        // Set the nonzero initial elements of BMAT and the quadratic model in the\n+        // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n+        // of the NF-th and (NF-N)-th interpolation points may be switched, in\n+        // order that the function value at the first of them contributes to the\n+        // off-diagonal second derivative terms of the initial quadratic model.\n+        if (numEval <= 2 * n + 1) {\n+            if (numEval >= 2 && numEval <= n + 1) {\n+                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n+                if (npt < numEval + n) {\n+                    final double oneOverStepA = 1 / stepa;\n+                    bMatrix.setEntry(0, nfmm, -oneOverStepA);\n+                    bMatrix.setEntry(nfm - 1, nfmm, oneOverStepA);\n+                    bMatrix.setEntry(npt + nfmm - 1, nfmm, -0.5 * rhosq);\n+                    continue;\n+                }\n+            } else if (numEval >= n + 2) {\n+                final int ih = nfx * (nfx - 1) / 2 + nfmm;\n+                final double tmp = (f - fbeg) / stepb;\n+                final double diff = stepb - stepa;\n+                modelSecondDerivativesValues.setEntry(ih, 2 * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n+                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n+                if (stepa * stepb < 0) {\n+                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n+                        fAtInterpolationPoints.setEntry(nfm - 1, fAtInterpolationPoints.getEntry(nfm - n - 1));\n+                        fAtInterpolationPoints.setEntry(nfm - n - 1, f);\n+                        if (trustRegionCenterInterpolationPointIndex == nfm - 1) {\n+                            trustRegionCenterInterpolationPointIndex = nfm - n - 1;\n                         }\n+                        interpolationPoints.setEntry(nfm - n - 1, nfxm, stepb);\n+                        interpolationPoints.setEntry(nfm - 1, nfxm, stepa);\n                     }\n-                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n-                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n-                    bMatrix.setEntry(nfm - n, nfxm,\n-                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n-                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n-                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n-                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n-                    zMatrix.setEntry(nfm - n, nfxm,\n-                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n                 }\n-\n-                // Set the off-diagonal second derivatives of the Lagrange functions and\n-                // the initial quadratic model.\n-\n-            } else {\n-                zMatrix.setEntry(0, nfxm, recip);\n-                zMatrix.setEntry(nfm, nfxm, recip);\n-                zMatrix.setEntry(ipt, nfxm, -recip);\n-                zMatrix.setEntry(jpt, nfxm, -recip);\n-\n-                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n-                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n-                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n-                throw new PathIsExploredException(); // XXX\n-            }\n-        } while (getEvaluations() < npt);\n-    } // prelim\n+                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n+                bMatrix.setEntry(nfm - 1, nfxm, -0.5 / interpolationPoints.getEntry(nfm - n - 1, nfxm));\n+                bMatrix.setEntry(nfm - n - 1, nfxm,\n+                        -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(\n \n \n     // ----------------------------------------------------------------------------------------",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}