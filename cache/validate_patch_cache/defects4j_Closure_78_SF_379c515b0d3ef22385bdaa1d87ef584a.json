{
    "patch": "private Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD\n            && (NodeUtil.mayBeString(left, false)\n            || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n\n    double result;\n\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little awkward here.\n\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n\n    double lval = lValObj;\n    double rval = rValObj;\n\n    switch (opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                DiagnosticType errorType = DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\",\n                        \"Divide by 0\");\n                JSError error = JSError.make(right, errorType);\n                compiler.report(error);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                DiagnosticType errorType = DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\",\n                        \"Divide by 0\");\n                JSError error = JSError.make(right, errorType);\n                compiler.report(error);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length()\n            <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n\n            // Do not try to fold arithmetic for numbers > 2^53. After that\n            // point, fixed-point math starts to break down and become inaccurate.\n            Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n\n    return null;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex c5ef4b0f..166c403c 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -661,89 +661,95 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n   /**\n    * Try to fold arithmetic binary operators\n    */\n-  private Node performArithmeticOp(int opType, Node left, Node right) {\n+private Node performArithmeticOp(int opType, Node left, Node right) {\n     // Unlike other operations, ADD operands are not always converted\n     // to Number.\n     if (opType == Token.ADD\n-        && (NodeUtil.mayBeString(left, false)\n+            && (NodeUtil.mayBeString(left, false)\n             || NodeUtil.mayBeString(right, false))) {\n-      return null;\n+        return null;\n     }\n \n     double result;\n \n     // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n-    // to zero so this is a little akward here.\n+    // to zero so this is a little awkward here.\n \n     Double lValObj = NodeUtil.getNumberValue(left);\n     if (lValObj == null) {\n-      return null;\n+        return null;\n     }\n     Double rValObj = NodeUtil.getNumberValue(right);\n     if (rValObj == null) {\n-      return null;\n+        return null;\n     }\n \n     double lval = lValObj;\n     double rval = rValObj;\n \n     switch (opType) {\n-      case Token.BITAND:\n-        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n-        break;\n-      case Token.BITOR:\n-        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n-        break;\n-      case Token.BITXOR:\n-        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n-        break;\n-      case Token.ADD:\n-        result = lval + rval;\n-        break;\n-      case Token.SUB:\n-        result = lval - rval;\n-        break;\n-      case Token.MUL:\n-        result = lval * rval;\n-        break;\n-      case Token.MOD:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval / rval;\n-        break;\n-      default:\n-        throw new Error(\"Unexpected arithmetic operator\");\n+        case Token.BITAND:\n+            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n+            break;\n+        case Token.BITOR:\n+            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n+            break;\n+        case Token.BITXOR:\n+            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n+            break;\n+        case Token.ADD:\n+            result = lval + rval;\n+            break;\n+        case Token.SUB:\n+            result = lval - rval;\n+            break;\n+        case Token.MUL:\n+            result = lval * rval;\n+            break;\n+        case Token.MOD:\n+            if (rval == 0) {\n+                DiagnosticType errorType = DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\",\n+                        \"Divide by 0\");\n+                JSError error = JSError.make(right, errorType);\n+                compiler.report(error);\n+                return null;\n+            }\n+            result = lval % rval;\n+            break;\n+        case Token.DIV:\n+            if (rval == 0) {\n+                DiagnosticType errorType = DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\",\n+                        \"Divide by 0\");\n+                JSError error = JSError.make(right, errorType);\n+                compiler.report(error);\n+                return null;\n+            }\n+            result = lval / rval;\n+            break;\n+        default:\n+            throw new Error(\"Unexpected arithmetic operator\");\n     }\n \n     // TODO(johnlenz): consider removing the result length check.\n     // length of the left and right value plus 1 byte for the operator.\n-    if (String.valueOf(result).length() <=\n-        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n-\n-        // Do not try to fold arithmetic for numbers > 2^53. After that\n-        // point, fixed-point math starts to break down and become inaccurate.\n-        Math.abs(result) <= MAX_FOLD_NUMBER) {\n-      Node newNumber = Node.newNumber(result);\n-      return newNumber;\n+    if (String.valueOf(result).length()\n+            <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n+\n+            // Do not try to fold arithmetic for numbers > 2^53. After that\n+            // point, fixed-point math starts to break down and become inaccurate.\n+            Math.abs(result) <= MAX_FOLD_NUMBER) {\n+        Node newNumber = Node.newNumber(result);\n+        return newNumber;\n     } else if (Double.isNaN(result)) {\n-      return Node.newString(Token.NAME, \"NaN\");\n+        return Node.newString(Token.NAME, \"NaN\");\n     } else if (result == Double.POSITIVE_INFINITY) {\n-      return Node.newString(Token.NAME, \"Infinity\");\n+        return Node.newString(Token.NAME, \"Infinity\");\n     } else if (result == Double.NEGATIVE_INFINITY) {\n-      return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n+        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n     }\n \n     return null;\n-  }\n+}\n \n   /**\n    * Expressions such as [foo() * 10 * 20] generate parse trees",
    "result_reason": "error: no suitable method found for make(Node,DiagnosticType)",
    "test_result": "ERROR"
}