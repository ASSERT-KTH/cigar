{
    "patch": "private void guessAOmega() {\n    // initialize the sums for the linear model between the two integrals\n    double sx2 = 0;\n    double sy2 = 0;\n    double sxy = 0;\n    double sxz = 0;\n    double syz = 0;\n\n    double currentX = observations[0].getX();\n    double currentY = observations[0].getY();\n    double f2Integral = 0;\n    double fPrime2Integral = 0;\n    final double startX = currentX;\n    for (int i = 1; i < observations.length; ++i) {\n        // one step forward\n        final double previousX = currentX;\n        final double previousY = currentY;\n        currentX = observations[i].getX();\n        currentY = observations[i].getY();\n\n        // update the integrals of f^2 and f'^2 considering a linear model for f (and therefore constant f')\n        final double dx = currentX - previousX;\n        final double dy = currentY - previousY;\n        final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n        final double fPrime2StepIntegral = dy * dy / dx;\n\n        final double x = currentX - startX;\n        f2Integral += f2StepIntegral;\n        fPrime2Integral += fPrime2StepIntegral;\n\n        sx2 += x * x;\n        sy2 += f2Integral * f2Integral;\n        sxy += x * f2Integral;\n        sxz += x * fPrime2Integral;\n        syz += f2Integral * fPrime2Integral;\n    }\n\n    // compute the amplitude and pulsation coefficients\n    final double c1 = sy2 * sxz - sxy * syz;\n    final double c2 = sxy * sxz - sx2 * syz;\n    final double c3 = sx2 * sy2 - sxy * sxy;\n    final double sqrtC1C2 = ComplexUtils.sqrt(new Complex(c1 / c2));\n    final double sqrtC2C3 = ComplexUtils.sqrt(new Complex(c2 / c3));\n    if (Double.isNaN(sqrtC1C2.getReal()) || Double.isNaN(sqrtC2C3.getReal())) {\n        final int last = observations.length - 1;\n        // Range of the observations, assuming that the observations are sorted.\n        final double xRange = observations[last].getX() - observations[0].getX();\n        if (xRange == 0) {\n            throw new ZeroException();\n        }\n        omega = 2 * Math.PI / xRange;\n\n        double yMin = Double.POSITIVE_INFINITY;\n        double yMax = Double.NEGATIVE_INFINITY;\n        for (int i = 1; i < observations.length; ++i) {\n            final double y = observations[i].getY();\n            if (y < yMin) {\n                yMin = y;\n            }\n            if (y > yMax) {\n                yMax = y;\n            }\n        }\n        a = 0.5 * (yMax - yMin);\n    } else {\n        a = sqrtC1C2.getReal();\n        omega = sqrtC2C3.getReal();\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\nindex 1da2c454e..054fd0669 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n@@ -254,79 +254,75 @@ public class HarmonicFitter extends CurveFitter<HarmonicOscillator.Parametric> {\n          * @throws MathIllegalStateException when the guessing procedure cannot\n          * produce sensible results.\n          */\n-        private void guessAOmega() {\n-            // initialize the sums for the linear model between the two integrals\n-            double sx2 = 0;\n-            double sy2 = 0;\n-            double sxy = 0;\n-            double sxz = 0;\n-            double syz = 0;\n+private void guessAOmega() {\n+    // initialize the sums for the linear model between the two integrals\n+    double sx2 = 0;\n+    double sy2 = 0;\n+    double sxy = 0;\n+    double sxz = 0;\n+    double syz = 0;\n \n-            double currentX = observations[0].getX();\n-            double currentY = observations[0].getY();\n-            double f2Integral = 0;\n-            double fPrime2Integral = 0;\n-            final double startX = currentX;\n-            for (int i = 1; i < observations.length; ++i) {\n-                // one step forward\n-                final double previousX = currentX;\n-                final double previousY = currentY;\n-                currentX = observations[i].getX();\n-                currentY = observations[i].getY();\n+    double currentX = observations[0].getX();\n+    double currentY = observations[0].getY();\n+    double f2Integral = 0;\n+    double fPrime2Integral = 0;\n+    final double startX = currentX;\n+    for (int i = 1; i < observations.length; ++i) {\n+        // one step forward\n+        final double previousX = currentX;\n+        final double previousY = currentY;\n+        currentX = observations[i].getX();\n+        currentY = observations[i].getY();\n \n-                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n-                // considering a linear model for f (and therefore constant f')\n-                final double dx = currentX - previousX;\n-                final double dy = currentY - previousY;\n-                final double f2StepIntegral =\n-                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n-                final double fPrime2StepIntegral = dy * dy / dx;\n+        // update the integrals of f^2 and f'^2 considering a linear model for f (and therefore constant f')\n+        final double dx = currentX - previousX;\n+        final double dy = currentY - previousY;\n+        final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n+        final double fPrime2StepIntegral = dy * dy / dx;\n \n-                final double x = currentX - startX;\n-                f2Integral += f2StepIntegral;\n-                fPrime2Integral += fPrime2StepIntegral;\n-\n-                sx2 += x * x;\n-                sy2 += f2Integral * f2Integral;\n-                sxy += x * f2Integral;\n-                sxz += x * fPrime2Integral;\n-                syz += f2Integral * fPrime2Integral;\n-            }\n+        final double x = currentX - startX;\n+        f2Integral += f2StepIntegral;\n+        fPrime2Integral += fPrime2StepIntegral;\n \n-            // compute the amplitude and pulsation coefficients\n-            double c1 = sy2 * sxz - sxy * syz;\n-            double c2 = sxy * sxz - sx2 * syz;\n-            double c3 = sx2 * sy2 - sxy * sxy;\n-            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n-                final int last = observations.length - 1;\n-                // Range of the observations, assuming that the\n-                // observations are sorted.\n-                final double xRange = observations[last].getX() - observations[0].getX();\n-                if (xRange == 0) {\n-                    throw new ZeroException();\n-                }\n-                omega = 2 * Math.PI / xRange;\n+        sx2 += x * x;\n+        sy2 += f2Integral * f2Integral;\n+        sxy += x * f2Integral;\n+        sxz += x * fPrime2Integral;\n+        syz += f2Integral * fPrime2Integral;\n+    }\n \n-                double yMin = Double.POSITIVE_INFINITY;\n-                double yMax = Double.NEGATIVE_INFINITY;\n-                for (int i = 1; i < observations.length; ++i) {\n-                    final double y = observations[i].getY();\n-                    if (y < yMin) {\n-                        yMin = y;\n-                    }\n-                    if (y > yMax) {\n-                        yMax = y;\n-                    }\n-                }\n-                a = 0.5 * (yMax - yMin);\n-            } else {\n-                    // In some ill-conditioned cases (cf. MATH-844), the guesser\n-                    // procedure cannot produce sensible results.\n+    // compute the amplitude and pulsation coefficients\n+    final double c1 = sy2 * sxz - sxy * syz;\n+    final double c2 = sxy * sxz - sx2 * syz;\n+    final double c3 = sx2 * sy2 - sxy * sxy;\n+    final double sqrtC1C2 = ComplexUtils.sqrt(new Complex(c1 / c2));\n+    final double sqrtC2C3 = ComplexUtils.sqrt(new Complex(c2 / c3));\n+    if (Double.isNaN(sqrtC1C2.getReal()) || Double.isNaN(sqrtC2C3.getReal())) {\n+        final int last = observations.length - 1;\n+        // Range of the observations, assuming that the observations are sorted.\n+        final double xRange = observations[last].getX() - observations[0].getX();\n+        if (xRange == 0) {\n+            throw new ZeroException();\n+        }\n+        omega = 2 * Math.PI / xRange;\n \n-                a = FastMath.sqrt(c1 / c2);\n-                omega = FastMath.sqrt(c2 / c3);\n+        double yMin = Double.POSITIVE_INFINITY;\n+        double yMax = Double.NEGATIVE_INFINITY;\n+        for (int i = 1; i < observations.length; ++i) {\n+            final double y = observations[i].getY();\n+            if (y < yMin) {\n+                yMin = y;\n+            }\n+            if (y > yMax) {\n+                yMax = y;\n             }\n         }\n+        a = 0.5 * (yMax - yMin);\n+    } else {\n+        a = sqrtC1C2.getReal();\n+        omega = sqrtC2C3.getReal();\n+    }\n+}\n \n         /**\n          * Estimate a first guess of the phase.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}